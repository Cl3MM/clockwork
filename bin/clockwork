#!/usr/bin/env ruby

STDERR.sync = STDOUT.sync = true

require File.expand_path('../../lib/clockwork', __FILE__)

usage = "clockwork <clock.rb>"
file = ARGV.shift or abort usage

file = "./#{file}" unless file.match(/^[\/.]/)

require file

trap('INT') do
  puts "\rExiting"
  exit
end

daemon = ARGV.shift

if daemon == "-d"
  begin
    require 'daemons'
    #require File.expand_path('../../lib/daemons', __FILE__)
  rescue LoadError
    raise "You need to add gem 'daemons' to your Gemfile or Rubygems if you wish to use it."
  end

  module Daemons
    class Application
      # Overrides the default logdir/{app_name}.log with logdir/{app_name}.exceptions.log
      # logfile is used for exception handling in Daemons::Application#exception_log

      def logfile
        puts options.map{ |k,v| "#{k} = #{v}"}.join("\n")
        puts "Loading Enhanced Daemons logfile"
        if logdir && options[:log_file]
          File.join(logdir, @group.app_name + 'exception.log')
        elsif logdir
          File.join(logdir, @group.app_name + '.log')
        else
          nil
        end
      end

      def output_logfile
        puts options.map{ |k,v| "#{k} = #{v}"}.join("\n")
        puts "Loading Enhanced Daemons output_logfile"
        if options[:log_file] && logdir
          log_path = File.join(logdir, options[:log_file])
          puts "Using #{ log_path } as log file."
          #File.open(log_path, "w"){ |f| f.puts "[#{Time.current}] Creating log file..."} unless File.exists? log_path
          log_path
        elsif options[:log_output] && logdir
          File.join(logdir, @group.app_name + '.output')
        else
          nil
        end
      end
    end
  end

  module Daemonize
    def call_as_daemon(block, logfile_name = nil, app_name = nil)
      puts "Yeah, calling my Uber function!!!"
      rd, wr = IO.pipe

      if tmppid = safefork
        # parent
        wr.close
        pid = rd.read.to_i
        rd.close

        Process.waitpid(tmppid)

        return pid
      else
        # child

        rd.close

        # Detach from the controlling terminal
        unless sess_id = Process.setsid
          raise Daemons.RuntimeException.new('cannot detach from controlling terminal')
        end

        # Prevent the possibility of acquiring a controlling terminal
        #if oldmode.zero?
        trap 'SIGHUP', 'IGNORE'
        exit if pid = safefork
        #end

        wr.write Process.pid
        wr.close

        $0 = app_name if app_name

        Dir.chdir "/"   # Release old working directory
        File.umask 0000 # Insure sensible umask

        # Make sure all file descriptors are closed
        #ObjectSpace.each_object(IO) do |io|
          #unless [STDIN, STDOUT, STDERR].include?(io)
            #begin
              #unless io.closed?
                #io.close
              #end
            #rescue ::Exception
            #end
          #end
        #end

        redirect_io(logfile_name)  

        block.call

        exit
      end
    end
    module_function :call_as_daemon
  end


  require 'tmpdir'
  require 'optparse'

  @options = {
    :quiet => true,
    :pid_dir => "#{Dir.tmpdir}",
    :log_output => false
  }

  opts = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename($0)} [options] start|stop|restart|run"
    opts.on('-h', '--help', 'Show this message') do
      puts opts
      exit 1
    end
    opts.on('-pd', '--pid-dir DIR', 'Specifies an alternate directory in which to store the process ids.') do |dir|
      @options[:pid_dir] = dir
    end
    opts.on('-i', '--identifier=str', 'An identifier for the process.') do |n|
      @options[:identifier] = n
    end
    opts.on('-l', '--log', 'Redirect both STDOUT and STDERR to a logfile named [app_name].output in the pid-file directory') do
      @options[:log_output] = true
    end
    opts.on('-ld', '--log-dir DIR', 'A specific directory to put the log files into (default location is pid directory)') do | log_dir |
      @options[:log_dir] = log_dir
    end
    opts.on('-lf', '--log-file FILE', 'Specifies an alternate name for the log file.') do | log_file |
      @options[:log_output] = true
      @options[:log_file]   = log_file
    end
    opts.on('-m', '--monitor', 'Start monitor process.') do
      @monitor = true
    end
  end

  @args = opts.parse!(ARGV)

  if @options[:identifier]
    process_name = "clockwork.#{@options[:identifier]}"
  else
    process_name = "clockwork"
  end

  dir = @options[:pid_dir]
  Dir.mkdir(dir) unless File.exists?(dir)

  Daemons.run_proc(process_name, :dir => dir, :dir_mode => :normal, :monitor => @monitor, :log_dir => @options[:log_dir], :log_file => @options[:log_file], :log_output => @options[:log_output], :ARGV => @args) do |*args|
    Clockwork::run
  end

else
  Clockwork::run
end
